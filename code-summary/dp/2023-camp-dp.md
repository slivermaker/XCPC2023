## 序列dp套路

1. 问有多少1 . . . n的排列，其中逆序对的数目恰为k , ( print ans mod 10000 , n , k <= 1000 )

​		f[i] [j] 表示考虑1...i 的排列，逆序对数目恰好为 j 的方案有多少个。第i+1个可以放在任意的位置，逆序对数量加[0...n-1]的某一个值

​		递推式:![image-20230319131320783](![image](https://user-images.githubusercontent.com/100915964/226166797-a16334bb-7a7f-454d-87ef-ca37a3e421eb.png))

​		复杂度：O（n * k * min(n , k) )		

​		前缀和优化：O(n*k)

2. 问有多少1 . . . n的排列，其中恰好有k对相邻的数满足前面的数比后面的数大 , ( print ans mod 1e9+7 , n , k <= 500 )

​		f[j] [j] [k] 表示考虑前i个位置，第 **i** 个位置上的数字是到**目前为止**第 **j** 小(大)的，满足条件的数恰好有k对方案有多少个.

​		转移方程:插入的是到目前为止最小的：f[i+1] [1] [k] =sum(f[i] [j] [k-1])  

​						一般情况：f[i+1] [j] [k] = if(j(i)>=j(i+1)) f[i] [j] [k-1] else f[i] [j] [k]

​		时间复杂度：O((n^2)*k)  前缀和优化

3. [G - Similar Permutation (atcoder.jp)](https://atcoder.jp/contests/abc282/tasks/abc282_g)

​		f[i] [j] [k] [l] 表示考虑了前i个位置，A的第i个位置上的数字是到**目前为止**第j大的，B的第i个位置上的数字是到目前为止第k大的，满足条件的数对恰好有l 对的方案有多少个.

## 填坑dp

问有多少1 . . . n的排列，其中恰好有k对相邻的数满足前面的数比后面的数大 , ( print ans mod 1e9+7 , n , k <= 500 )

​	f[i] [j] [k]表示考虑了1...i这些数，这i个数在最后的排列中构成连续的j段，到目前为止满足条件

数恰好有k个。

 转移：第k+1个数可以插入到某两段的中间把两端连接起来答案贡献1，可以依附在某一段的左边贡献1  右边贡献0  也可以自己当作一段贡献0

 复杂度O(n^2*k)	
